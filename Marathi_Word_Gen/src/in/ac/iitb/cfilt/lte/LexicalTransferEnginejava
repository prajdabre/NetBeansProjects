/**
 * Project 	 : English-Hindi Wordnet Linking
 * 
 * Team 	 : CFILT, IIT Bombay.
 *
 * File Name : LexicalTransferEngine.java
 *
 * Created On: Sep 23, 2007
 *
 * Revision History:
 * Modification Date 	Modified By		Comments
 * 
 */
package in.ac.iitb.cfilt.lte;

import in.ac.iitb.cfilt.common.config.GlobalConstants;
import in.ac.iitb.cfilt.common.data.DSFRecord;
import in.ac.iitb.cfilt.common.data.Language;
import in.ac.iitb.cfilt.common.data.POS;
import in.ac.iitb.cfilt.common.exception.MultilingualDictException;
import in.ac.iitb.cfilt.getopt.Getopt;
import in.ac.iitb.cfilt.getopt.LongOpt;
import in.ac.iitb.cfilt.multidict.dictionary.Dictionary;
import in.ac.iitb.cfilt.multidict.dictionary.FileBackedDictionary;

import java.io.File;
import java.io.IOException;
import java.util.Vector;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;

import sanchay.corpus.ssf.SSFProperties;
import sanchay.corpus.ssf.SSFSentence;
import sanchay.corpus.ssf.SSFStory;
import sanchay.corpus.ssf.features.FeatureAttribute;
import sanchay.corpus.ssf.features.FeatureStructure;
import sanchay.corpus.ssf.features.FeatureValue;
import sanchay.corpus.ssf.features.impl.FSProperties;
import sanchay.corpus.ssf.features.impl.FeatureStructuresImpl;
import sanchay.corpus.ssf.features.impl.FeatureValueImpl;
import sanchay.corpus.ssf.impl.SSFStoryImpl;
import sanchay.corpus.ssf.tree.SSFNode;
/**
 * Class	: LexicalTransferEngine
 * Purpose	: This class is used to find the translation of a source language word
 * 			  to the target language. 
 */
public class LexicalTransferEngine {
	
	/**
	 * This field stores the path of the USER_HOME variable.
	 */
	public static String USER_HOME = null;
	
	/**
	 * This field stores the logger for this class. 
	 */
	private static Logger logger = Logger.getLogger(LexicalTransferEngine.class);
	
	/**
	 * This field stores a handle to the user dictionary object.
	 */
	private Dictionary userDict = null;

	/**
	 * This field stores a handle to the system dictionary object.
	 */
	private Dictionary systemDict = null;
	
	/**
	 * This field stores a handle to the session dictionary object.
	 */
	private Dictionary sessionDict = null;

	private Dictionary NNPDict = null;
	private Dictionary BilingualDict = null;

	private static String AT = "@";
	private static String PUNC="punc";
	
	
	public static String userDictPath = null; 
	public static String sessionDictPath = null; 
	public static String systemDictPath = null;
	public static String NNPDictPath = null;
	public static String BilingualDictPath = null;
	
	
	public static Language sourceLanguage = null;
	public static Language targetLanguage = null;
	
	private static boolean usePOSTags = false;
	
	/**
	 * <p><b>Method</b> 	: initialize
	 * <p><b>Purpose</b>	: Initializes the Lexical Transfer Engine with the
	 * 						  correct dictionary path.
	 * <p><b>@param dictionaryPath - The base directory for the location of the dictionary.
	 * <p><b>@throws MultilingualDictException</b>
	 */
	public void initialize(String USER_HOME, boolean openUserDict, boolean openSessionDict, boolean openSystemDict,
			boolean openNNPDict, boolean openBilingualDict) throws MultilingualDictException {
		logger.info("Initializing Lexical Transfer Engine");
		
		this.USER_HOME = USER_HOME;

		//String dictionaryPath = USER_HOME + File.separator + 
		//						"data_bin" + File.separator +
		//						"sl_tl" + File.separator + "lexicaltransfer";
		
        String default_system_dict_path = USER_HOME + File.separator + "data_bin" + File.separator + 
        		"sl_tl" + File.separator + "lexicaltransfer" + File.separator+ "system_dict"; 
        		// + File.separator + sourceLanguage.toString().toLowerCase() + "-" + targetLanguage.toString().toLowerCase();
        String default_user_dict_path = USER_HOME + File.separator + "data_bin" + File.separator + 
        		"sl_tl" + File.separator + "lexicaltransfer" + File.separator+ "user_dict"; 
        		// + File.separator+ sourceLanguage.toString().toLowerCase() + "-" + targetLanguage.toString().toLowerCase(); 
        String default_session_dict_path = USER_HOME + File.separator + "data_bin" + File.separator + 
        		"sl_tl" + File.separator + "lexicaltransfer" + File.separator+ "session_dict"; 
        		// + File.separator + sourceLanguage.toString().toLowerCase() + "-" + targetLanguage.toString().toLowerCase();		
        String default_NNP_dict_path = USER_HOME + File.separator + "data_bin" + File.separator + 
		"sl_tl" + File.separator + "lexicaltransfer" + File.separator+ "NNP_dict"; 
        		// + File.separator + sourceLanguage.toString().toLowerCase() + "-" + targetLanguage.toString().toLowerCase();		
        String default_Bilingual_dict_path = USER_HOME + File.separator + "data_bin" + File.separator + 
		"sl_tl" + File.separator + "lexicaltransfer" + File.separator+ "Bilingual_dict"; 
        		// 	+ File.separator + sourceLanguage.toString().toLowerCase() + "-" + targetLanguage.toString().toLowerCase();		
		
        if(openUserDict) {        	
        	userDict = Dictionary.getInstance("userDict");
        	if(userDictPath != null) {
        		String userDictPathSt = getDefaultPath(userDictPath,
            			sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
            	if(!checkIfDirectoryExists(userDictPathSt)) {
            		userDictPathSt = getDefaultPath(userDictPath,
                			targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
                	if(!checkIfDirectoryExists(userDictPathSt)) {
                		logger.info("Dictionary path " + userDictPathSt + " does not exist. Please specify the corect dictionary path");
                	}
            	}
            	userDict.initialize(userDictPathSt, sourceLanguage, targetLanguage);	// init after getting path
            } else {
            	String default_user_dict_path_st = getDefaultPath(default_user_dict_path,
            			sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
            	if(!checkIfDirectoryExists(default_user_dict_path_st)) {
            		default_user_dict_path_st = getDefaultPath(default_user_dict_path,
                			targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
                	if(!checkIfDirectoryExists(default_user_dict_path_st)) {
                		logger.info("Default dictionary path " + default_user_dict_path_st + " does not exist. Please specify the dictionary path");
                	}
            	}
            	userDict.initialize(default_user_dict_path_st, sourceLanguage, targetLanguage);	// init after getting path
            }    		        	
        }
        
        if(openSessionDict) {        	
        	sessionDict = Dictionary.getInstance("sessionDict");
        	if(sessionDictPath != null) {            	
        		String sessionDictPathSt = getDefaultPath(sessionDictPath,
            			sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
            	if(!checkIfDirectoryExists(sessionDictPathSt)) {
            		sessionDictPathSt = getDefaultPath(sessionDictPath,
                			targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
                	if(!checkIfDirectoryExists(sessionDictPathSt)) {
                		logger.info("Dictionary path " + sessionDictPathSt + " does not exist. Please specify the corect dictionary path");
                	}
            	}
            	sessionDict.initialize(sessionDictPathSt, sourceLanguage, targetLanguage);	// init after getting path
            } else {
            	String default_session_dict_path_st = getDefaultPath(default_session_dict_path,
            			sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
            	if(!checkIfDirectoryExists(default_session_dict_path_st)) {
            		default_session_dict_path_st = getDefaultPath(default_session_dict_path,
                			targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
                	if(!checkIfDirectoryExists(default_session_dict_path_st)) {
                		logger.info("Default dictionary path " + default_session_dict_path_st + " does not exist. Please specify the dictionary path");
                	}
            	}
            	sessionDict.initialize(default_session_dict_path_st, sourceLanguage, targetLanguage);	// init after getting path
            }    		        	
        }
        
        if(openSystemDict) {        	
        	systemDict = Dictionary.getInstance("systemDict");
        	if(systemDictPath != null) {            	
        		String systemDictPathSt = getDefaultPath(systemDictPath,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(systemDictPathSt)) {
        			systemDictPathSt = getDefaultPath(systemDictPath,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(systemDictPathSt)) {
        				logger.info("Dictionary path " + systemDictPathSt + " does not exist. Please specify the corect dictionary path");
        			}
        		}
        		systemDict.initialize(systemDictPathSt, sourceLanguage, targetLanguage);	// init after getting path
        	} else {
        		String default_system_dict_path_st = getDefaultPath(default_system_dict_path,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(default_system_dict_path_st)) {
        			default_system_dict_path_st = getDefaultPath(default_system_dict_path,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(default_system_dict_path_st)) {
        				logger.info("Default dictionary path " + default_system_dict_path_st + " does not exist. Please specify the dictionary path");
        			}
        		}
        		systemDict.initialize(default_system_dict_path_st, sourceLanguage, targetLanguage);	// init after getting path
        	}    		        	
        }    

        if(openNNPDict) {        	
        	NNPDict = Dictionary.getInstance("NNPDict");
        	if(NNPDictPath != null) {            	
        		String NNPDictPathSt = getDefaultPath(NNPDictPath,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(NNPDictPathSt)) {
        			NNPDictPathSt = getDefaultPath(NNPDictPath,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(NNPDictPathSt)) {
        				logger.info("Dictionary path " + NNPDictPathSt + " does not exist. Please specify the corect dictionary path");
        			}
        		}
        		NNPDict.initialize(NNPDictPathSt, sourceLanguage, targetLanguage);	// init after getting path
        	} else {
        		String default_NNP_dict_path_st = getDefaultPath(default_NNP_dict_path,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(default_NNP_dict_path_st)) {
        			default_NNP_dict_path_st = getDefaultPath(default_NNP_dict_path,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(default_NNP_dict_path_st)) {
        				logger.info("Default dictionary path " + default_NNP_dict_path_st + " does not exist. Please specify the dictionary path");
        			}
        		}
        		NNPDict.initialize(default_NNP_dict_path_st, sourceLanguage, targetLanguage);	// init after getting path
        	}    		        	
        }    

        if(openBilingualDict) {        	
        	BilingualDict = Dictionary.getInstance("BilingualDict");
        	if(BilingualDictPath != null) {            	
        		String BilingualDictPathSt = getDefaultPath(BilingualDictPath,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(BilingualDictPathSt)) {
        			BilingualDictPathSt = getDefaultPath(BilingualDictPath,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(BilingualDictPathSt)) {
        				logger.info("Dictionary path " + BilingualDictPathSt + " does not exist. Please specify the corect dictionary path");
        			}
        		}
        		BilingualDict.initialize(BilingualDictPathSt, sourceLanguage, targetLanguage);	// init after getting path
        	} else {
        		String default_Bilingual_dict_path_st = getDefaultPath(default_Bilingual_dict_path,
        				sourceLanguage.toString().toLowerCase(), targetLanguage.toString().toLowerCase());
        		if(!checkIfDirectoryExists(default_Bilingual_dict_path_st)) {
        			default_Bilingual_dict_path_st = getDefaultPath(default_Bilingual_dict_path,
        					targetLanguage.toString().toLowerCase(), sourceLanguage.toString().toLowerCase());
        			if(!checkIfDirectoryExists(default_Bilingual_dict_path_st)) {
        				logger.info("Default dictionary path " + default_Bilingual_dict_path_st + " does not exist. Please specify the dictionary path");
        			}
        		}
        		BilingualDict.initialize(default_Bilingual_dict_path_st, sourceLanguage, targetLanguage);	// init after getting path
        	}    		        	
        }    
        
		//TODO logger.info(dictionaryPath);
		//EnglishILMapper.initialize(dictionaryPath + File.separator + "EnglishILMap.txt");
	}

	/**
	 * <p><b>Method</b> 	: translate
	 * <p><b>Purpose</b>	: Translates the inputFileName from sourceLanguage to targetLanguage
	 * 						  and stores the output in outputFileName  
	 * <p><b>@param inputFileName - The name of the input file/directory.
	 * <p><b>@param outputFileName- The name of the output file/directory.
	 * <p><b>@param sourceLanguage- source language. 
	 * <p><b>@param targetLanguage- target language.
	 * <p><b>@throws MultilingualDictException</b>
	 */
	public void translate (String inputFileName,
			String outputFileName, Language sourceLanguage, Language targetLanguage) 
		throws MultilingualDictException  {
		File input = new File(inputFileName);
/*		if(input.isDirectory()) {
			File[] children = input.listFiles();
			for(int i=0; i<children.length; i++) {
				translate(children[i].getAbsolutePath(),
						outputFileName + File.separator + children[i].getName(),
						sourceLanguage,
						targetLanguage);
			}
		} else {
			if(!outputFileName.endsWith(".txt") && !outputFileName.endsWith(".out")) {
				outputFileName = outputFileName + File.separator + input.getName();
			}
*/			transfer(input.getAbsolutePath(),
					outputFileName,
					sourceLanguage,
					targetLanguage);
		//}
	}
	
	/**
	 * <p><b>Method</b> 	: transfer
	 * <p><b>Purpose</b>	: translates the file to target language. 
	 * <p><b>@param inputFileName - Input file name.
	 * <p><b>@param outputFileName- Output file name.
	 * <p><b>@param sourceLanguage- Source Language
	 * <p><b>@param targetLanguage- Target Language
	 * <p><b>@throws MultilingualDictException</b>
	 */
	private void transfer (String inputFileName,String outputFileName, Language sourceLanguage, Language targetLanguage)throws MultilingualDictException  
	{
		try
		{
			logger.info("Translating file " + inputFileName);
			File output = null;
			if(outputFileName != null) 
			{
				output = new File(outputFileName).getParentFile();
				if(output != null && !output.exists()) 
					output.mkdirs();	
			}
			
			FSProperties fsp = new FSProperties();
			SSFProperties ssfp = new SSFProperties();
			SSFProperties cmlp = new SSFProperties();
			SSFStory story = new SSFStoryImpl();
			String SANCHAY_HOME =  USER_HOME + File.separator + "data_bin" + File.separator + 
			"sl_tl" + File.separator + "lexicaltransfer"+ File.separator + "Sanchay";

			logger.debug("SANCHAY_HOME = " + SANCHAY_HOME);
			fsp.read(SANCHAY_HOME + File.separator + "props" + File.separator + "fs-mandatory-attribs.txt",
					SANCHAY_HOME + File.separator + "props" + File.separator + "fs-props.txt", "UTF-8"); 
			ssfp.read(SANCHAY_HOME + File.separator + "props" + File.separator + "ssf-props.txt", "UTF-8"); 
			cmlp.read(SANCHAY_HOME + File.separator + "props" + File.separator + "cml-props.txt", "UTF-8");
			FeatureStructuresImpl.setFSProperties(fsp);
			SSFNode.setSSFProperties(ssfp);
			SSFNode.setCMLProperties(cmlp);

			story.readFile(inputFileName); 

			int scount = story.countSentences();		
			for (int i = 0; i < scount; i++) 
			{
				SSFSentence sen = story.getSentence(i);
				int ccount = sen.getRoot().countChildren();

				for (int j = 0; j < ccount; j++) 
				{				
					SSFNode node = sen.getRoot().getChild(j); 
					String sourceWord="", sourceTam="";
					String targetWords[]=null, targetTams[]=null;
					FeatureAttribute nodefaWord = null;
					FeatureAttribute nodefatam = null;
					FeatureAttribute nodefapos = null;
					POS pos = null;
					//if (node.getFeatureStructures()==null){
					String synsetId = null;
					String lexWord = node.getLexData();
					sourceWord = lexWord.trim();
					
					if(node.getFeatureStructures()!= null && node.getFeatureStructures().getChildCount() > 0) 
					{
						FeatureStructure nodefs = node.getFeatureStructures().getAltFSValue(0);
						nodefaWord = nodefs.getAttribute(0);
						if(nodefaWord !=null) 
							sourceWord = nodefaWord.getAltValue(0).toString();

						nodefatam = nodefs.getAttribute(6);
						if(nodefatam !=null) 
							sourceTam = nodefatam.getAltValue(0).toString();

						nodefapos = nodefs.getAttribute(1);
						if(nodefapos !=null) 
							pos = getCategory(nodefapos.getAltValue(0).toString());
						
						if(usePOSTags)
							pos = getCategory(node.getName());
						
						int countAttrib = nodefs.countAttributes();
						FeatureAttribute attrib = null;
						boolean isNamedEntity = false;
						for(int m=0; m < countAttrib; m++)
						{
							attrib = nodefs.getAttribute(m);
							if(attrib != null)
							{ 
								if(attrib.getName().equalsIgnoreCase("ENAMEX_TYPE"))
									isNamedEntity = true;
								if(attrib.getName().equalsIgnoreCase("SYNSETID"))
									synsetId = (String) attrib.getAltValue(0).getValue();
							}
						}
						sourceWord = sourceWord.trim();
						sourceTam = sourceTam.trim();
						// If the word is a Named Entity then ignore its translation. It would be transliterated
						boolean caratPrefixWord = sourceWord.startsWith(GlobalConstants.CARAT);
						boolean tildaPrefixWord = sourceWord.startsWith(GlobalConstants.TILDA);
						if(!isNamedEntity && !caratPrefixWord && !tildaPrefixWord)
							targetWords = getTranslation(sourceWord, pos, sourceLanguage, targetLanguage, synsetId);

						boolean caratPrefixTAM = sourceTam.startsWith(GlobalConstants.CARAT);
						boolean tildaPrefixTAM = sourceTam.startsWith(GlobalConstants.TILDA);
						// As WSD is currently working only for content words, we pass false to the function
						if(!caratPrefixTAM && !tildaPrefixTAM) 
						{
							if(pos == POS.VERB)
							{
								targetTams = getTranslation(sourceTam, POS.TAM, sourceLanguage, targetLanguage, null);
//								if(targetTams == null || targetTams.length == 0)
//								targetTams = getTranslation(sourceTam, POS.FW, sourceLanguage, targetLanguage);
							}
							else
								targetTams = getTranslation(sourceTam, POS.FW, sourceLanguage, targetLanguage, null);
						}

						if(targetWords == null || targetWords.length == 0) 
						{
							if(caratPrefixWord || tildaPrefixWord)
							{
								logger.debug(sourceWord + " starts with ^, ^^ or ~");
								sourceWord = sourceWord.replaceFirst("\\^\\^|\\^", "");
								node.setLexData(sourceWord);

								if(nodefaWord != null) 
								{
									FeatureValue newaTagetWord = new FeatureValueImpl();
									newaTagetWord.setValue(sourceWord);
									nodefaWord.modifyAltValue(newaTagetWord, 0);
								}
							} else {
								if(isNamedEntity)
									logger.debug(sourceWord + " is a Named Entity and would be transliterated");
								else
									logger.debug("No translation found for " + sourceWord);

								if(!nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceWord.trim().equals(""))
									node.setLexData(AT+sourceWord);

								if(nodefaWord != null && !nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceWord.trim().equals("")) 
								{
									FeatureValue newaTagetWord = new FeatureValueImpl();
									newaTagetWord.setValue(AT+sourceWord);
									nodefaWord.modifyAltValue(newaTagetWord, 0);
								}
							}
						}else 
						{
							logger.debug("Translation for " + sourceWord + " is " + targetWords[0]);
							node.setLexData(targetWords[0]);
							if(nodefaWord != null) 
							{
								FeatureValue newaTagetWord = new FeatureValueImpl();
								newaTagetWord.setValue(targetWords[0]);
								nodefaWord.modifyAltValue(newaTagetWord, 0);
							}
						}
						// Setting TAM value
						if(targetTams == null || targetTams.length == 0)
						{
							if(caratPrefixTAM || tildaPrefixTAM)
							{
								logger.debug(sourceTam + " starts with ^, ^^ or ~");
								sourceTam = sourceTam.replaceFirst("\\^\\^|\\^", "");
								if(nodefatam != null)
								{
									FeatureValue newaTam = new FeatureValueImpl();
									newaTam.setValue(sourceTam);
									nodefatam.modifyAltValue(newaTam, 0);
								}
							} else {
								if(nodefatam != null && !nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceTam.trim().equals(""))
								{
									FeatureValue newaTam = new FeatureValueImpl();
									newaTam.setValue(AT+sourceTam);
									nodefatam.modifyAltValue(newaTam, 0);
									logger.debug("No translation found for TAM " + sourceTam);
								}
							}
						}else if(nodefatam != null)
						{
							logger.debug("Translation for " + sourceTam + " is " + targetTams[0]);
							FeatureValue newaTam = new FeatureValueImpl();
							newaTam.setValue(targetTams[0]);
							nodefatam.modifyAltValue(newaTam, 0);
						}
					}
					for(int k=0;k<node.countChildren();k++)
					{
						targetTams = null;
						targetWords = null;
						synsetId = null;
						SSFNode nodeChild = (SSFNode) node.getChildAt(k);
						//if (nodeChild.getFeatureStructures()==null){
						sourceWord = nodeChild.getLexData();
						lexWord = nodeChild.getLexData();
						sourceWord = lexWord.trim();

						if(nodeChild.getFeatureStructures()!= null && nodeChild.getFeatureStructures().getChildCount() > 0) 
						{
							FeatureStructure nodefs = nodeChild.getFeatureStructures().getAltFSValue(0);
							nodefaWord = nodefs.getAttribute(0);
							if(nodefaWord !=null) 
								sourceWord = nodefaWord.getAltValue(0).toString();

							nodefatam = nodefs.getAttribute(6);
							if(nodefatam !=null) 
								sourceTam = nodefatam.getAltValue(0).toString();

							nodefapos = nodefs.getAttribute(1);
							if(nodefapos !=null) 
								pos = getCategory(nodefapos.getAltValue(0).toString());

							if(usePOSTags)
								pos = getCategory(nodeChild.getName());

							int countAttrib = nodefs.countAttributes();
							FeatureAttribute attrib = null;
							boolean isNamedEntity = false;
							for(int m=0; m < countAttrib; m++)
							{
								attrib = nodefs.getAttribute(m);
								if(attrib != null)
								{
									if(attrib.getName().equalsIgnoreCase("ENAMEX_TYPE"))
										isNamedEntity = true;
									if(attrib.getName().equalsIgnoreCase("SYNSETID"))
										synsetId = (String) attrib.getAltValue(0).getValue();
								}
							}
							sourceWord = sourceWord.trim();
							sourceTam = sourceTam.trim();

							// If the word is a Named Entity then ignore its translation. It would be transliterated
							boolean caratPrefixWord = sourceWord.startsWith(GlobalConstants.CARAT);
							boolean tildaPrefixWord = sourceWord.startsWith(GlobalConstants.TILDA);
							if(!isNamedEntity && !caratPrefixWord && !tildaPrefixWord)
								targetWords = getTranslation(sourceWord, pos, sourceLanguage, targetLanguage, synsetId);

							
							boolean caratPrefixTAM = sourceTam.startsWith(GlobalConstants.CARAT);
							boolean tildaPrefixTAM = sourceTam.startsWith(GlobalConstants.TILDA);
							// As WSD is currently working only for content words, we pass false to the function
							if(!caratPrefixTAM && !tildaPrefixTAM) 
							{
								if(pos == POS.VERB)
								{
									targetTams = getTranslation(sourceTam, POS.TAM, sourceLanguage, targetLanguage, null);
//									if(targetTams == null || targetTams.length == 0)
//									targetTams = getTranslation(sourceTam, POS.FW, sourceLanguage, targetLanguage);
								}
								else
									targetTams = getTranslation(sourceTam, POS.FW, sourceLanguage, targetLanguage, null);
							}
							
							if(targetWords == null || targetWords.length == 0) 
							{
								if(caratPrefixWord || tildaPrefixWord)
								{
									logger.debug(sourceWord + " starts with ^, ^^ or ~");
									sourceWord = sourceWord.replaceFirst("\\^\\^|\\^", "");
									nodeChild.setLexData(sourceWord);

									if(nodefaWord != null) 
									{
										FeatureValue newalue = new FeatureValueImpl();
										newalue.setValue(sourceWord);
										nodefaWord.modifyAltValue(newalue, 0);
									}
								} else {
									if(isNamedEntity)
										logger.debug(sourceWord + " is a Named Entity and would be transliterated");
									else
										logger.debug("No translation found for " + sourceWord);
										
									if(!nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceWord.trim().equals(""))
										nodeChild.setLexData(AT + sourceWord);

									if(nodefaWord != null && !nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceWord.trim().equals("")) 
									{
										FeatureValue newalue = new FeatureValueImpl();
										newalue.setValue(AT+sourceWord);
										nodefaWord.modifyAltValue(newalue, 0);
									}
								}
							}else 
							{
								logger.debug("Translation for " + sourceWord + " is " + targetWords[0]);
								nodeChild.setLexData(targetWords[0]);
								if(nodefaWord != null) 
								{
									FeatureValue newalue = new FeatureValueImpl();
									newalue.setValue(targetWords[0]);
									nodefaWord.modifyAltValue(newalue, 0);
								}
							}
							// Setting TAM value
							if(targetTams == null || targetTams.length == 0)
							{
								if(caratPrefixTAM || tildaPrefixTAM)
								{
									logger.debug(sourceTam + " starts with ^, ^^ or ~");
									sourceTam = sourceTam.replaceFirst("\\^\\^|\\^", "");
									if(nodefatam != null)
									{
										FeatureValue newaTam = new FeatureValueImpl();
										newaTam.setValue(sourceTam);
										nodefatam.modifyAltValue(newaTam, 0);
									}
								} else {
									if(nodefatam != null && !nodefapos.getAltValue(0).toString().equals(PUNC) && !sourceTam.trim().equals(""))
									{
										FeatureValue newaTam = new FeatureValueImpl();
										newaTam.setValue(AT+sourceTam);
										nodefatam.modifyAltValue(newaTam, 0);
										logger.debug("No translation found for TAM " + sourceTam);
									}
								}
							}else if(nodefatam != null)
							{
								logger.debug("Translation for " + sourceTam + " is " + targetTams[0]);

								FeatureValue newaTam = new FeatureValueImpl();
								newaTam.setValue(targetTams[0]);
								nodefatam.modifyAltValue(newaTam, 0);
							}
						}
					}
				}
			}

			if(outputFileName != null) 
				story.save(outputFileName, "UTF-8");	
			else 
				story.print(System.out);	

		}catch (Exception ex) 
		{						
			logger.fatal("Error while processing input SSF file.");
			throw new MultilingualDictException("Error while processing input SSF file.", ex);
		}
	}

	/**
	 * <p><b>Method</b> 	: getTranslation
	 * <p><b>Purpose</b>	: Returns the translation of the source word. 
	 * <p><b>@param lemma - source word	
	 * <p><b>@param pos	- POS category
	 * <p><b>@param sourceLanguage - Source Language
	 * <p><b>@param targetLanguage - Target Language
	 * <p><b>@return</b> - Returns an array containing the translations of the source 
	 * 					   word in the target language. 
	 * @param isDisambiguated 
	 */
	public String[] getTranslation(
			String lemma,
			POS pos, 
			Language sourceLanguage, 
			Language targetLanguage, String synsetId) {
		try {
			String[] output = null; 
			if(sessionDict != null){
				output = getCrossLinkedWords(sessionDict, lemma, sourceLanguage, targetLanguage, pos, synsetId);					
			} 
			if(output == null || output.length == 0) 
			{
				if(userDict != null)
				{
					output = getCrossLinkedWords(userDict, lemma, sourceLanguage, targetLanguage, pos, synsetId);
				}
				if(output == null || output.length == 0) 
				{
					if(NNPDict != null) 
					{
						output = getCrossLinkedWords(NNPDict, lemma, sourceLanguage, targetLanguage, pos, synsetId);
					}
					if(output == null || output.length ==0)
					{
						if(systemDict != null) 
						{
							output = getCrossLinkedWords(systemDict, lemma, sourceLanguage, targetLanguage, pos, synsetId);
						}
						if(output == null || output.length == 0)
						{
							if(BilingualDict != null) 
							{
								output = getCrossLinkedWords(BilingualDict, lemma, sourceLanguage, targetLanguage, pos, synsetId);
							}
							if(output == null || output.length == 0)
							{
								if(!lemma.equals(""))
									logger.debug("\""+lemma+"\"" + " is not present in any dictionary");
							}
							else
								logger.debug("\""+lemma+"\"" + " is present in Bilingual dictionary.");
						} else {
							logger.debug("\""+lemma+"\"" + " is present in system dictionary.");
						}
					} else {
						logger.debug("\""+lemma+"\"" + " is present in NNP dictionary.");
					}
				} else {
					logger.debug("\""+lemma+"\"" + " is present in user dictionary.");
				}
			} else {
				logger.debug("\""+lemma+"\"" + " is present in session dictionary.");
			}
			
			return output;
		} catch (MultilingualDictException ex) {
			ex.printStackTrace();
			System.err.println("No matching word found");
		}
		return null;
	}

	/**
	 * Method 	: getCategory
	 * Purpose	: 
	 * @param strCategory
	 * @return
	 */
	public POS getCategory_POS(String strCategory) 
	{
		if(strCategory.startsWith("N"))
			return POS.NOUN;
		if(strCategory.startsWith("JJ"))
			return POS.ADJECTIVE;
		if(strCategory.startsWith("RB"))
			return POS.ADVERB;
		if(strCategory.startsWith("V"))	
			return POS.VERB;
		return POS.FW;
	}

	/**
	 * Method 	: getCategory
	 * Purpose	: 
	 * @param strCategory
	 * @return
	 */
	public POS getCategory_LCAT(String strCategory) 
	{
		if(strCategory.equals("n"))
			return POS.NOUN;
		if(strCategory.equals("adj"))
			return POS.ADJECTIVE;
		if(strCategory.equals("adv"))
			return POS.ADVERB;
		if(strCategory.equals("v"))
			return POS.VERB;
		return POS.FW;
	}

	public POS getCategory(String strCategory) 
	{
		if(usePOSTags)
			return getCategory_POS(strCategory);
		else
			return getCategory_LCAT(strCategory);
	}
	/**
	 * Method 	: main
	 * Purpose	: Dummy main for testing purpose. 
	 * @param args
	 * @throws MultilingualDictException 
	 * @throws IOException 
	 */
	public static void main (String args[]) throws MultilingualDictException, IOException {
		
		String inputFileName = null;
		int debugLevel = 1;
		String outputFileName = null;
		String logFile=null;
		int c;
		
		// 
		//ReadEnv.load();
		//USER_HOME = ReadEnv.getProperty("USER_HOME");
		//USER_HOME = "/media/D/NewCleanBuild";
		//StringBuffer sb = new StringBuffer();
		LongOpt[] longopts = new LongOpt[8];
		StringBuffer systemDict = new StringBuffer();
		StringBuffer userDict = new StringBuffer();
		StringBuffer sessionDict = new StringBuffer();
		StringBuffer NNPDict = new StringBuffer();
		StringBuffer BiDict = new StringBuffer();
		StringBuffer logFilePath = new StringBuffer();
		
		boolean openUserDict = false;
		boolean openSessionDict = false;
		boolean openSystemDict = false;
		boolean openNNPDict = false;
		boolean openBilingualDict = false;
		
		longopts[0] = new LongOpt("help", LongOpt.NO_ARGUMENT, null, 'h');
		longopts[1] = new LongOpt("system-dict", LongOpt.OPTIONAL_ARGUMENT, systemDict , 'y' );
		longopts[2] = new LongOpt("session-dict", LongOpt.OPTIONAL_ARGUMENT, sessionDict, 'e' );
		longopts[3] = new LongOpt("user-dict", LongOpt.OPTIONAL_ARGUMENT, userDict , 'r');
		longopts[4] = new LongOpt("NNP-dict", LongOpt.OPTIONAL_ARGUMENT, NNPDict , 'n');
		longopts[5] = new LongOpt("Bilingual-dict", LongOpt.OPTIONAL_ARGUMENT, BiDict , 'l');
		longopts[6] = new LongOpt("Use POSTags", LongOpt.NO_ARGUMENT, null , 'p');
		longopts[6] = new LongOpt("LogFile Path", LongOpt.REQUIRED_ARGUMENT, logFilePath , 'j');
		
		Getopt g = new Getopt("LexicalTransferEngine", args, "-:i:o:s:t:d:u:y::e::r::n::l::p::j:h", longopts);
		g.setOpterr(false);
		while ((c = g.getopt()) != -1) {
			switch (c) {
			case 0:
			case 'h':	
				System.out.println("Usage:\n java -classpath " +
						"$setu/bin/sl_tl/lexicaltransfer/common:" +
						"$setu/bin/sl_tl/lexicaltransfer/common/lib/MultiDictAPIs.jar:" +
						"$setu/bin/sl_tl/lexicaltransfer/common/lib/SSFAPI.jar:" +
						"$setu/bin/sl_tl/lexicaltransfer/common/lib/log4j-1.2.15.jar" +
						" in.ac.iitb.cfilt.lte.engine.LexicalTransferEngine " +
						" [-options]\n" +
						" where options include\n" +
						" -h --help\t\t for help on sample usage\n" +
						" -u \t\t path of USER_HOME directory. In our case this will be the path of setu directory\n" +
						" -i \t\t for specifying input file name (mandatory)  \n" +
						" -o \t\t for specifying output file name (mandatory) \n" +
						" -s \t\t for specifying source language (3-letter language code, mandatory)\n" +
						" -t \t\t for specifying target language (3-letter language code, mandatory)\n" +
						" -e [path] \t\t for enabling session specific dictionary to be used " +
						"	and optionally specifying its location" + 
						" -r user-dict [path] \t\t for enabling user specific dictionary to be used " +
						"	and optionally specifying its location" +
						" -y [path] \t\t for enabling system specific dictionary to be used " +
						"	and optionally specifying its location" +						
						" -n [path] \t\t for enabling Proper Noun(NNP) dictionary to be used " +
						"	and optionally specifying its location" +						
						" -l [path] \t\t for enabling Bilingual dictionary to be used " +
						"	and optionally specifying its location" +						
						" -j [path] \t\t for specifying path of the log file\n" +
						" -d \t\t for specifying debug level (optional) Possible log levels are:\n" +
						" -d \t\t " +
						"\t\t\t\tLOG_LEVEL:\n\t\t\t\t\t1 : INFO(default)\n\t\t\t\t\t2 : DEBUG\n\t\t\t\t\t3 : ALL\n\t\t\t\t\t4 : OFF");
				System.exit(0);
				
			//
			case 'o':
				outputFileName = g.getOptarg();
				break;
			//
			case 'u':
				USER_HOME = g.getOptarg();
				break;
			//
			case 'i':
				inputFileName = g.getOptarg();
				break;
			//
			case 's':
				sourceLanguage = Language.getLanguage(g.getOptarg());
				break;
			//
			case 't':
				targetLanguage = Language.getLanguage(g.getOptarg());
				break;
			//
			case 'y':
				systemDictPath = g.getOptarg();
				openSystemDict = true;
				break;
			//
			case 'e':
				sessionDictPath = g.getOptarg();
				openSessionDict = true;
				break;
				//
			case 'r':
				userDictPath= g.getOptarg();
				openUserDict = true;
				break;
				//
			case 'n':
				NNPDictPath= g.getOptarg();
				openNNPDict = true;
				break;
				//
			case 'l':
				BilingualDictPath= g.getOptarg();
				openBilingualDict = true;
				break;
			case 'p':
				usePOSTags = true;
				break;
			//
			case 'j':
				logFile = g.getOptarg();
				break;
			case 'd':
				try {
					debugLevel = Integer.parseInt(g.getOptarg());
				} catch (Exception ex) {
					System.out.println("Debug level should be a valid integer"); 
				}
				break;
			//
				
			case ':':
				System.out.println("You need an argument for option "
						+ (char) g.getOptopt());
				System.exit(0);
			//
			case '?':
				System.out.println("The option '" + (char) g.getOptopt()
						+ "' is not valid");
				System.exit(0);
			//
			default:
				System.out.println("getopt() returned " + c);
				break;
			}
		}

		if(USER_HOME == null) {
			System.out.println("You must specify option 'u' for 'USER_HOME' directory i.e the path of setu directory");
			System.exit(0);
		}
		if(inputFileName == null) {
			System.out.println("You must specify option 'i' for 'input file' ");
			System.exit(0);
		}
/*		if(outputFileName == null) {
			System.out.println("You must specify option 'o' for 'output file' ");
			System.exit(0);
		}
*/		if(sourceLanguage == null) {
			System.out.println("You must specify option 's' for 'source language' ");
			System.exit(0);
		}
		if(targetLanguage == null) {
			System.out.println("You must specify option 't' for 'target language' ");
			System.exit(0);
		}
		BasicConfigurator.configure();
		if(logFile != null)
		{
			FileAppender fappender = new FileAppender(new PatternLayout("%-6p [%t] (%F:%L) %m%n"), logFile);
			logger.addAppender(fappender);
		}
		switch (debugLevel) {
		case 1:
			logger.setLevel(Level.INFO);
			break;
		case 2:
			logger.setLevel(Level.DEBUG);
			break;
		case 3:
			logger.setLevel(Level.ALL);
			break;
		case 4:
			logger.setLevel(Level.OFF);
			break;
		}

		logger.info("$setu="+ USER_HOME);
		if(systemDictPath != null && !checkIfDirectoryExists(systemDictPath)) {
			logger.info("Specified directory " + systemDictPath + " does not exist.");
			System.exit(0);
		}
		
		if(userDictPath != null && !checkIfDirectoryExists(userDictPath)) {
			logger.info("Specified directory " + userDictPath + " does not exist.");
			System.exit(0);
		}

		if(sessionDictPath != null && !checkIfDirectoryExists(sessionDictPath)) {
			logger.info("Specified directory " + sessionDictPath + " does not exist.");
			System.exit(0);
		}

		if(NNPDictPath != null && !checkIfDirectoryExists(NNPDictPath)) {
			logger.info("Specified directory " + NNPDictPath + " does not exist.");
			System.exit(0);
		}

		if(BilingualDictPath != null && !checkIfDirectoryExists(BilingualDictPath)) {
			logger.info("Specified directory " + BilingualDictPath + " does not exist.");
			System.exit(0);
		}

		LexicalTransferEngine lte = new LexicalTransferEngine();
		lte.initialize(USER_HOME, openUserDict, openSessionDict, openSystemDict, openNNPDict, openBilingualDict);
		lte.translate(inputFileName, outputFileName, sourceLanguage,
				targetLanguage);
		if(outputFileName != null) {
			logger.info("Translation done. Please check the output file/dir "
					+ outputFileName);
		}
	}
	
	private static boolean checkIfDirectoryExists(String dirName) {
		if(dirName == null)
			return false;
		return new File(dirName).exists() && new File(dirName).isDirectory();
	}
	
	private String getDefaultPath(String path, String language1, String language2) {
		return path  + File.separator + language1 + "-" + language2;
	}
	
	private String[] getCrossLinkedWords(Dictionary dict,String lemma,Language sourceLanguage,
					Language targetLanguage,POS pos, String synsetId) throws MultilingualDictException
	{
		if(dict instanceof FileBackedDictionary)
			dict = (FileBackedDictionary)dict;
		
		String[] crossLinkedWords = null;
		if(synsetId != null)
		{
			DSFRecord dsfr = dict.getDSFRecord(synsetId, pos, sourceLanguage);
			if(dsfr != null)
			{
				if(pos == null)
					crossLinkedWords = dict.getCrossLinkedWords(lemma, sourceLanguage, targetLanguage, synsetId);
				else
					crossLinkedWords = dict.getCrossLinkedWords(lemma, sourceLanguage, targetLanguage, synsetId, pos);

				if(crossLinkedWords != null)
					return crossLinkedWords;
			}
		}

		
		DSFRecord[] dsfRecords;
		if(pos == null)
			dsfRecords = dict.getDSFRecords(lemma, sourceLanguage);
		else
			dsfRecords = dict.getDSFRecords(lemma, pos, sourceLanguage);

		if(dsfRecords != null)
		{
			int lIndex = Integer.MAX_VALUE; 
			for(int count=0; count< dsfRecords.length; count++)
			{
				if(dsfRecords[count] != null)
				{
					Vector<String> vwords = dsfRecords[count].getWords();
					if(vwords != null)
					{
						int curIndex = vwords.indexOf(lemma);
						if(curIndex < lIndex && curIndex >= 0)
						{
							lIndex = curIndex;
							synsetId = dsfRecords[count].getID();
						}
					}
				}
			}

			if(synsetId != null)
			{
				if(pos == null)
					crossLinkedWords = dict.getCrossLinkedWords(lemma, sourceLanguage, targetLanguage, synsetId);
				else
					crossLinkedWords = dict.getCrossLinkedWords(lemma, sourceLanguage, targetLanguage, synsetId, pos);
			}
		}
		return crossLinkedWords;
	}
}
